#' @title Determine a File's Extension or Remove the Extension from the File Path
#'
#' @description Based on the separating character, \code{file_ext} determines the file extension and \code{path_no_ext} determines the file path without the extension.
#'
#' @param path \code{character} value of the file path possibly with an extension.
#'
#' @param sep_char \code{character} value of the separator that delineates the extension from the file path. Generally, this will be \code{"."}, but for some API URLs, the extension is actually a query component, so the separator may sometimes need to be \code{"="}.
#'
#' @return \code{character} value of the extension (\code{file_ext}) or the path without the extension (\code{path_no_ext}.
#' 
#' @examples
#'  file_ext("home/folders.with.dots/stuff/ok.csv")
#'  path_no_ext("home/folders.with.dots/stuff/ok.csv")
#'  file_ext(NMME_urls()[[1]])
#'  file_ext(NMME_urls()[[1]], "=")
#'
#' @export
#'
file_ext <- function (path, sep_char = ".") {
  
  for_regexpr <- paste0("\\", sep_char, "([[:alnum:]]+)$")
  pos         <- regexpr(for_regexpr, path)

  ifelse(pos > -1L, substring(path, pos + 1L), "")

}

#' @rdname file_ext
#'
#' @export
#'
path_no_ext <- function (path, sep_char = ".") {
  
  for_sub <- paste0("([^", sep_char, "]+)\\.[[:alnum:]]+$")
  sub(for_sub, "\\1", path)

}



#' @title Argument Matching with Defaults
#'
#' @description Expansion of \code{\link[base]{match.call}} to include default formal values.
#'
#' @param definition A \code{function}, by default the function from which \code{match.call.defaults} is called. 
#'
#' @param call An unevaluated \code{call} to the function specified by \code{definition}, as generated by \code{\link[base]{call}}.
#'
#' @param expand.dots \code{logical} defining if arguments matching \code{...} in the call be included or left as a \code{...} argument
#'
#' @param envir An \code{environment}, from which the \code{...} in \code{call} are retrieved, if any.
#'
#' @references 
#'  DesignLibrary's \code{match.call.defaults} function. \cr
#'  Stack overflow post reply by Roland. \href{https://bit.ly/2PtEgy1}{URL}
#'
#' @examples
#'  fun <- function(arg1 = "ok", ...) {
#'    match.call.defaults()
#'  }
#'  fun()
#'  fun(arg2 = "hi")
#'
#' @export
#'
match.call.defaults <- function (definition  = sys.function(sys.parent()), 
                                 call        = sys.call(sys.parent()), 
                                 expand.dots = TRUE, 
                                 envir       = parent.frame(2L)) {

  call <- match.call(definition  = definition, 
                     call        = call, 
                     expand.dots = expand.dots, 
                     envir       = envir)

  formals <- formals(fun = definition)

  if (expand.dots && "..." %in% names(formals)) {

      formals[["..."]] <- NULL

  }

  diffs <- setdiff(names(formals), names(call))

  for (i in diffs) {

    call[i] <- list(formals[[i]])

  }

  match.call(definition  = definition, 
             call        = call,
             expand.dots = TRUE, 
             envir       = envir)

}

#' @title Create a Named Empty List
#'
#' @description Produces a list with \code{NULL} for each element named according to \code{element_names}.
#' 
#' @param element_names \code{character} vector of names for the elements in the list.
#'
#' @return \code{list} with names \code{element_names} and values \code{NULL}.
#'
#' @examples
#'  named_null_list(c("a", "b", "c"))
#'
#' @export
#'
named_null_list <- function (element_names = NULL) {

  return_if_null(element_names)

  nelements  <- length(element_names)
  out        <- vector("list", nelements)
  names(out) <- element_names

  out

}

#' @title Error if a Function's Request is Deeper than can be Handled
#'
#' @description Produces an informative error message when a function that should only be called inside of other functions is called outside of a function (hence the request to the function is too deep for what it can handle).
#' 
#' @param lev The number of frames back in the stack where the request needs to be able to be evaluated.
#'
#' @return Throws an error if the function is called in a place where it cannot operate and returns \code{NULL} otherwise.
#'
#' @examples
#'  \dontrun{
#'  # will error:
#'  # error_if_deep(-10)
#'  }
#'  error_if_deep(0)
#'
#' @export
#'
error_if_deep <- function (lev) {

  lev2     <- lev - 1
  too_deep <- tryCatch(sys.call(lev2), error = function(x){NA})

  if (!is.null(too_deep) && !is.call(too_deep) && is.na(too_deep)) {

    stop("too deep; function should only be called inside other functions")

  } 

}



#' @title Update a List's Elements
#'
#' @description Update a list with new values for elements
#'
#' @param list \code{list} to be updated with \code{...}. 
#'
#' @param ... Named elements to update in \code{list}
#'
#' @return Updated \code{list}.
#'
#' @examples
#'  orig_list <- list(a = 1, b = 3, c = 4)
#'  update_list(orig_list)
#'  update_list(orig_list, a = "a")
#'  update_list(orig_list, a = 10, b = NULL)
#'
#' @export
#'
update_list <- function (list = list(),
                                ...) {

  if (!is.list(list)) {

    stop("`list` must be a list")

  } 

  update_elems <- list(...)

  nupdate_elems <- length(update_elems)
  norig_elems   <- length(list)

  updated_list <- named_null_list(element_names = names(list))

  if (norig_elems > 0) {

    for (i in 1:norig_elems) {

      if (!is.null(list[[i]])) {

        updated_list[[i]] <- list[[i]]

      }

    }

  }

  if (nupdate_elems > 0) {

    names_update_elems <- names(update_elems)

    for (i in 1:nupdate_elems) {

      if (!is.null(update_elems[[i]])) {

        updated_list[[names_update_elems[i]]] <- update_elems[[i]]

      }

    }

  }

  updated_list

}



#' @title Save Data Out to a csv, Appending the File if it Already Exists
#'
#' @description Appending a \code{.csv} without re-writing the header of the file. If the doesn't exist, it will be created.
#'
#' @param df \code{data.frame} table to be written out.
#'
#' @param filename \code{character} filename of existing \code{.csv} to be appended.
#'
#' @return \code{NULL}.
#'
#' @examples
#'  \donttest{
#'   df <- data.frame(x = 1:10)
#'   fpath <- file.path("xx.csv")
#'   append_csv(df, fpath)
#'  }
#'
#' @export
#'
append_csv <- function(df, filename){
  
  write.table(x         = df, 
              file      = filename, 
              sep       = ",", 
              row.names = FALSE, 
              col.names = !file.exists(filename), 
              append    = file.exists(filename))

  NULL

}

#' @title Calculate the Fraction of the Year from a Date
#' 
#' @description Based on the year in which the date occurred, determine the fraction of the year (foy) for the date (in relation to New Year's Eve in that year). 
#'
#' @param dates \code{Date}(s) or \code{Date}-conformable value(s) to be converted to the fraction of the year.
#'
#' @return \code{numeric} value(s) of the fraction of the year.
#'
#' @examples
#'  foy(Sys.Date())
#'
#' @export
#'
foy <- function (dates = NULL) {

  return_if_null(dates)
  
  dates   <- as.Date(dates)
  jday    <- as.numeric(format(dates, "%j"))
  nye     <- as.Date(paste0(format(dates, "%Y"), "-12-31"))
  nyejday <- as.numeric(format(nye, "%j"))

  round(jday / nyejday, 3)

}



#' @title Combine a Historical Table and a Cast Table
#'
#' @description A simple utility for combining a table of historical data and a table of cast data that might need to be assigned to either one or the other.
#'
#' @param hist_tab,cast_tab A pair of \code{data.frame}s with the same columns including a code{date} column of \code{Date}s, which is used to align them.
#'
#' @param winner \code{character} value either {"hist"} or \code{"cast"} to decide who wins any ties. In the typical portalcasting space, this is kept at its default value throughout. In the case of \code{NA} values, this will be overriden to use the entry that has no missing entries.
#'
#' @param column \code{character} indicating the column to use for identifying entries in combining.
#'
#' @return \code{data.frame} combining \code{hist_tab} and \code{cast_tab}.
#' 
#' @examples
#'  hist_tab <- data.frame(date = seq(Sys.Date(), Sys.Date() + 5, 1), x = 1:6)
#'  cast_tab <- data.frame(date = seq(Sys.Date() + 5, Sys.Date() + 10, 1), x = 101:106)
#'  combine_hist_and_cast(hist_tab, cast_tab, "hist") 
#'  combine_hist_and_cast(hist_tab, cast_tab, "cast")  
#'
#' @export
#'
combine_hist_and_cast <- function (hist_tab = NULL, 
                                   cast_tab = NULL, 
                                   winner   = "hist", 
                                   column   = "date"){
  
  return_if_null(hist_tab, cast_tab)
  return_if_null(cast_tab, hist_tab)

  hist_tab$x_source <- "hist"
  cast_tab$x_source <- "cast"

  out    <- rbind(hist_tab, cast_tab)
  in_out <- rep(TRUE, NROW(out))

  if (!(winner %in% c("hist", "cast"))) {

    stop("`winner` must be `hist` or `cast`")

  }

  dupes  <- names(which(table(out[,column]) > 1))
  ndupes <- length(dupes) 

  if (ndupes > 0) {

    for (i in 1:ndupes) {

      which_duped      <- which(out$moon == dupes[i])
      which_duped_hist <- which(as.character(out[,column]) == dupes[i] & out$x_source == "hist")
      which_duped_cast <- which(as.character(out[,column]) == dupes[i] & out$x_source == "cast") 

      hist_dupe_NA <- any(is.na(out[which_duped_hist, ]))
      cast_dupe_NA <- any(is.na(out[which_duped_cast, ]))

      if (winner == "hist") {

        if (!hist_dupe_NA) {

          in_out[which_duped_cast] <- FALSE

        } else {

          in_out[which_duped_hist] <- FALSE   

        }

      } else if(winner == "cast") {

        if (!cast_dupe_NA) {

          in_out[which_duped_hist] <- FALSE

        } else {

          in_out[which_duped_cast] <- FALSE   

        }

      }

    }

  }

  out <- out[ , -which(colnames(out) == "x_source")]

  out[in_out, ]

}

#' @title Add a Date to a Table That has the Year, Month, and Day as Components 
#' 
#' @description Add a date (as a \code{Date}) column to a table that has the year month and day as components.
#' 
#' @param df \code{data.frame} with columns named \code{year}, \code{month}, and \code{day}. 
#'
#' @return \code{data.frame} \code{df} with column of \code{Date}s named \code{date} added.
#'
#' @examples
#'  df <- data.frame(year = 2010, month = 2, day = 1:10)
#'  add_date_from_components(df)
#'
#' @export
#'
add_date_from_components <- function (df) {
  
  yrs     <- df$year
  mns     <- df$month
  dys     <- df$day
  df$date <- as.Date(paste(yrs, mns, dys, sep = "-"))
  df

}




#' @title Remove any Specific Incomplete Entries as Noted by an NA
#'
#' @description Remove any incomplete entries in a table, as determined by the presence of an \code{NA} entry in a specific column (\code{colname}).
#'
#' @param df \code{data.frame} table to be written out.
#'
#' @param colname A single \code{character} value of the column to use to remove incomplete entries. 
#'
#' @return \code{df} without any incomplete entries. 
#'
#' @examples
#'  df <- data.frame(c1 = c(1:9, NA), c2 = 11:20)
#'  remove_incompletes(df, "c1")
#'
#' @export
#'
remove_incompletes <- function (df, colname) {
  
  incompletes <- which(is.na(df[ , colname]))

  if (length(incompletes) > 0) {

    df <- df[-incompletes, ]

  }

  df

}

#' @title Determine the Depth of a List
#'
#' @description Evaluate an input for the depth of its nesting. 
#'
#' @details If \code{xlist = list()}, then technically the input value is a list, but is empty (of length \code{0}), so depth is returned as \code{0}.
#'
#' @param xlist Focal input \code{list}.
#'
#' @return \code{integer} value of the depth of the list.
#' 
#' @examples
#'  list_depth("a")
#'  list_depth(list())
#'  list_depth(list("a"))
#'  list_depth(list(list("a")))
#'
#' @export 
#'
list_depth <- function (xlist) {

  xx  <- match.call()
  xxx <- deparse(xx[[2]])

  if(xxx == "list()") {

    0L

  } else if (is.list(xlist)) {

    1L + max(sapply(xlist, list_depth))

  } else {

    0L

  }

}

#' @title If a Value is NULL, Trigger the Parent Function's Return
#'
#' @description If the focal input is \code{NULL}, return \code{value} from the parent function. Should only be used within a function.
#'
#' @param x Focal input.
#'
#' @param value If \code{x} is \code{NULL}, \code{\link{return}} this input from the parent function. 
#'
#' @return If \code{x} is not \code{NULL}, \code{NULL} is returned. If \code{x} is \code{NULL}, the result of \code{\link{return}} with \code{value} as its input evaluated within the parent function's environment is returned.
#' 
#' @examples
#'  ff <- function(x = 1, null_return = "hello"){
#'    return_if_null(x, null_return)
#'    x
#'  }
#'  ff()
#'  ff(NULL)
#'
#' @export 
#'
return_if_null <- function (x, value = NULL) {

  if (is.null(x)) {

    do.call(what  = return, 
            args  = list(value), 
            envir = sys.frame(-1))

  } 

}


#' @title Replace a Value with an Alternative if it is NULL or if it is NA
#'
#' @description 
#'  \code{ifnull} replaces the focal input with the alternative value if it is \code{NULL}. \cr \cr
#'  \code{ifna} replaces the focal input with the alternative value if it is \code{NA}.
#'
#' @param x Focal input.
#'
#' @param alt Alternative value.
#'
#' @return 
#'  \code{ifnull}: \code{x} if not \code{NULL}, \code{alt} otherwise. \cr \cr
#'  \code{ifna}:  \code{x} if not \code{NA}, \code{alt} otherwise. 
#' 
#' @examples
#'  ifnull(NULL, 123)
#'  ifnull(TRUE, 123)
#'  ifnull(FALSE, 123)
#'  ifna(NA, 123)
#'  ifna(FALSE, 123)
#'  ifna(NA, NA)
#'
#' @name alternative values
#'
#' @export 
#'
ifnull <- function (x = NULL, alt = NULL) {

  if (is.null(x)) {

    x <- alt

  }

  x

}

#' @rdname alternative-values
#'
#' @export 
#'
ifna <- function (x = NULL, alt = NA) {

  ifelse(is.na(x), alt, x)

}



#' @title Optionally generate a message based on a logical input
#'
#' @description A wrapper on \code{\link[base]{message}} that, given the input to \code{quiet}, generates the message(s) in \code{...} or not.
#'
#' @param ... zero or more objects that can be coerced to \code{character} and are concatenated with no separator added, or a single condition object. See \code{\link[base]{message}}.
#'
#' @param quiet \code{logical} indicator if the message should be generated. 
#'
#' @param domain The domain for the translation. If \code{NA}, messages will not be translated. See \code{\link[base]{message}} and \code{\link[base]{gettext}}.
#'
#' @param appendLF \code{logical} indicator if messages given as a \code{character} string should have a newline appended. See \code{\link[base]{message}}.
#'
#' @return A message is given, and \code{NULL} returned.
#'
#' @export
#'
messageq <- function (..., 
                      quiet    = FALSE, 
                      domain   = NULL, 
                      appendLF = TRUE) {

  if (!quiet) {

    message(...,
            domain   = domain,
            appendLF = appendLF)

  }

  invisible()

}


#' @title Produce a Horizontal Break Line for Messaging
#'
#' @description Creates a horizontal line of characters for messages.
#'
#' @param char \code{character} value to repeated \code{reps} times to form the break. 
#'
#' @param reps \code{integer}-conformable value for number of times \code{char} is replicated.
#' 
#' @return \code{NULL} (message is put out to console).
#'
#' @examples
#'  message_break()
#'
#' @export
#'
message_break <- function(char = "-",
                          reps = 60){
  
  paste(rep(char, reps), collapse = "") 

}


#' @title Add a Newmoon Number Column to a Table that has a Date Column 
#' 
#' @description Add a \code{newmoonnumber} column to a table that has a \code{date} column.
#' 
#' @param df \code{data.frame} with column of \code{date}s.
#'
#' @param moons Moons \code{data.frame}. See \code{\link{prep_moons}}.
#'
#' @return \code{data.frame} \code{df} with column of \code{newmoonnumber}s added.
#'
#' @export
#'
add_newmoonnumbers_from_dates <- function (df, moons = NULL) {

  return_if_null(moons, df)

  if (is.null(df$date)) {

    df <- add_date_from_components(df)
  }

  moon_number       <- moons$newmoonnumber[-1]
  moon_start        <- as.Date(moons$newmoondate[-nrow(moons)])
  moon_end          <- as.Date(moons$newmoondate[-1])
  moon_match_number <- NULL
  moon_match_date   <- NULL

  for (i in seq(moon_number)) {

    temp_dates        <- seq.Date(moon_start[i] + 1, moon_end[i], 1)
    temp_dates        <- as.character(temp_dates)
    temp_numbers      <- rep(moon_number[i], length(temp_dates))
    moon_match_date   <- c(moon_match_date, temp_dates)
    moon_match_number <- c(moon_match_number, temp_numbers)

  }

  moon_match_date  <- as.Date(moon_match_date)
  moon_matches     <- match(df$date, moon_match_date)
  df$newmoonnumber <- moon_match_number[moon_matches]

  df

}
