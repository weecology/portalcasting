#' @title Forecast covariates for forecasting or hindcasting
#' 
#' @description \code{forecast_covariates}: Forecast covariates (NDVI and 
#'   weather) based on the forecast type (\code{"forecast"} or 
#'   \code{"hindcast"}) as indicated by \code{options_covariates$cast_type}.
#'
#' @param covariate_data Class-\code{covariates} \code{data.frame} of 
#'   historical covariate data generated by 
#'   \code{\link{prep_hist_covariates}}.
#'
#' @param moons Class-\code{moons} \code{data.frame} containing the historic 
#'   and future newmoons, as produced by \code{\link{prep_moons}}. For input 
#'   into \code{forecast_weather} and \code{forecast_ndvi}, \code{moons} 
#'   should be trimmed by \code{\link{trim_moons_fcast}}.
#'
#' @param options_covariates Class-\code{covariates_options} list of 
#'   options for the covariate data. See \code{\link{covariates_options}}.
#'
#' @return \code{forecast_covariates}: \code{data.frame} with needed 
#'   forecasted covariates.
#'
#' @export
#'
forecast_covariates <- function(covariate_data, moons, 
                                options_covariates = covariates_options()){
  if (!("covariates_options") %in% class(options_covariates)){
    stop("`options_covariates` is not a covariates_options list")
  }
  if (!("moons" %in% class(moons))){
    stop("`moons` is not of class moons")
  }
  if (!("covariates" %in% class(covariate_data))){
    stop("`covariate_data` is not of class covariates")
  }
  if (options_covariates$cast_type == "forecasts"){
    moons <- trim_moons_fcast(moons, options_covariates)
    weather_f <- forecast_weather(moons, options_covariates)
    ndvi_f <- forecast_ndvi(covariate_data, moons, options_covariates)
    fcast <- right_join(weather_f, ndvi_f, by = "newmoonnumber")
    forecast_newmoon <- max(moons$newmoonnumber)
    out <- round(data.frame(forecast_newmoon, fcast), 3)
  }
  if (options_covariates$cast_type == "hindcasts"){
    end_step <- options_covariates$end[options_covariates$hind_step]
    path <- file_path(options_covariates$tree, "data/covariate_forecasts.csv")
    hist_fcast <- read.csv(path, stringsAsFactors = FALSE)
    nmin <- hist_fcast$newmoonnumber %in% options_covariates$fcast_nms
    esin <- hist_fcast$forecast_newmoon %in% end_step
    out <- select(hist_fcast[which(nmin & esin), ], -date_made)
  }
  classy(out, c(options_covariates$class, "data.frame"))
}

#' @rdname forecast_covariates
#' 
#' @description \code{forecast_ndvi}: Wraps around 
#'   \code{\link[portalr]{fcast_ndvi}} to forecast specific NDVI values
#'   as requested by a portalcasting directory based on existing NDVI values
#'   (from \code{covariate_data}) and \code{moons} data, and controlled by
#'   \code{options_covariates} (see \code{\link{covariates_options}}).
#'
#' @return \code{forecast_ndvi}: \code{data.frame} of needed forecasted NDVI
#'   values.
#'
#' @export
#'
forecast_ndvi <- function(covariate_data, moons, options_covariates){
  if (!("covariates_options") %in% class(options_covariates)){
    stop("`options_covariates` is not a covariates_options list")
  }
  if (!("moons" %in% class(moons))){
    stop("`moons` is not of class moons")
  }
  if (!("covariates" %in% class(covariate_data))){
    stop("`covariate_data` is not of class covariates")
  }
  ndvi_data <- select(covariate_data, c("newmoonnumber", "ndvi"))
  ndvi_lead <- options_covariates$nfcnm - options_covariates$min_lag
  fcast_ndvi(ndvi_data, "newmoon", lead = ndvi_lead, moons)
}

#' @rdname forecast_covariates
#' 
#' @description \code{forecast_weather}: Wraps around 
#'   \code{\link{get_climate_forecasts}} to forecast weather covariates 
#'   (min, max, and mean of temperatures and total precipitation for each
#'   newmoon) as requested by a portalcasting directory and controlled through
#'   \code{options_covariates} (see \code{\link{covariates_options}}).
#'
#' @return \code{forecast_weather}: \code{data.frame} of needed forecasted
#'   temperature and precipiation values.
#'
#' @export
#'
forecast_weather <- function(moons = prep_moons(), 
                             options_covariates = covariates_options()){
  if (!("covariates_options") %in% class(options_covariates)){
    stop("`options_covariates` is not a covariates_options list")
  }  
  if (!("moons" %in% class(moons))){
    stop("`moons` is not of class moons")
  }
  mpath <- main_path(options_covariates$tree)
  dayweather <- weather("daily", fill = TRUE, mpath)
  yrs <- dayweather$year
  mns <- dayweather$month
  dys <- dayweather$day
  dayweather$date <- as.Date(paste(yrs, mns, dys, sep = "-"))

  newmoon_number <- moons$newmoonnumber[-1]
  newmoon_start <- as.Date(moons$newmoondate[-nrow(moons)])
  newmoon_end <- as.Date(moons$newmoondate[-1])
  newmoon_match_number <- NULL
  newmoon_match_date <- NULL

  for (i in seq(newmoon_number)) {
    temp_dates <- seq.Date(newmoon_start[i] + 1, newmoon_end[i], 1)
    temp_dates <- as.character(temp_dates)
    temp_numbers <- rep(newmoon_number[i], length(temp_dates))
    newmoon_match_date <- c(newmoon_match_date, temp_dates)
    newmoon_match_number <- c(newmoon_match_number, temp_numbers)
  }
  newmoon_match_date <- as.Date(newmoon_match_date)
  matches <- match(dayweather$date, newmoon_match_date)
  dayweather$newmoonnumber <- newmoon_match_number[matches]
  newweather <- dayweather %>% 
                group_by(newmoonnumber) %>% 
                summarize(date = max(date, na.rm = TRUE), 
                          mintemp = min(mintemp, na.rm = TRUE), 
                          maxtemp = max(maxtemp, na.rm = TRUE), 
                          meantemp = mean(meantemp, na.rm = TRUE), 
                          precipitation = sum(precipitation, na.rm = TRUE), 
                          locally_measured = all(locally_measured), 
                          battery_low = all(battery_low, na.rm = TRUE)) %>% 
               arrange(newmoonnumber) %>% 
               select(newmoonnumber, date, mintemp, maxtemp, meantemp, 
                      precipitation, locally_measured, battery_low) %>% 
               mutate(battery_low = ifelse(date < "2003-01-01", 
                   NA, battery_low)) %>% 
               select(-c(.data$locally_measured, .data$battery_low)) %>% 
               mutate(year = as.numeric(format(date, "%Y"))) %>% 
               filter(year >= options_covariates$start - 5)
    incompletes <- which(is.na(newweather$newmoonnumber))
    if (length(incompletes) > 0) {
        newweather <- newweather[-incompletes, ]
    }
    fcasts <- get_climate_forecasts(moons, options_covariates)
    tail(newweather, options_covariates$min_lag) %>% 
    select(-year, -date) %>% 
    bind_rows(fcasts)
}


#' @title Trim the moons table for covariate forecasting
#' 
#' @description Covariate forecasting requires a moons data table that is
#'   trimmed to the moons of interest only. 
#'
#' @param moons Class-\code{moons} type of a \code{data.frame} containing the
#'   moons and date data. See \code{\link{prep_moons}}.
#'
#' @param options_covariates Class-\code{covariates_options} options 
#'   \code{list}. See \code{\link{covariates_options}}.
#'
#' @return A trimmed \code{moons} \code{data.frame}.
#'
#' @export
#'
trim_moons_fcast <- function(moons, options_covariates){
  if (!("moons" %in% class(moons))){
    stop("`moons` is not of class moons")
  }
  if (!("covariates_options") %in% class(options_covariates)){
    stop("`options_covariates` is not a covariates_options list")
  } 
  moons <- moons[, c("newmoonnumber", "newmoondate", "period", "censusdate")]
  fc_nms <- moons
  addl_fcast <- which(moons$newmoonnumber %in% options_covariates$fcast_nms)
  if (length(addl_fcast) > 0){
    fc_nms <- fc_nms[-addl_fcast, ]
  }
  fc_nms
}

#' @title Download downscaled weather forecasts for Portal
#' 
#' @description Lunar cycle-based climate forecasts obtained from 
#'   \href{https://climate.northwestknowledge.net/RangelandForecast/download.php}{Northwest Knowledge
#'   Network (NKN) at the University of Idaho}
#'   and downscaled to Portal, AZ (31.9555, -109.0744). The downscaled 
#'   forecasts are based on the 
#'   \href{http://www.cpc.ncep.noaa.gov/products/NMME/}{North American 
#'   Multi-Model Ensemble}, and specifically the ENSMEAN (ensemble mean) 
#'   model. 
#' 
#' @param moons Class-\code{moons} type of a \code{data.frame} containing the
#'   moons and date data. See \code{\link{prep_moons}}.
#'
#' @param options_covariates Class-\code{covariates_options} options 
#'   \code{list}. See \code{\link{covariates_options}}.
#' 
#' @return Class-\code{climate_forecast} \code{data.frame} with columns 
#'   of \code{newmoonnumber}, \code{mintemp}, \code{maxtemp}, \code{meantemp},
#'   and \code{precipitation}. Temperatures are in C, precipitation is in mm.
#'
#' @export
#'
get_climate_forecasts <- function(moons = prep_moons(), 
                                  options_covariates = covariates_options()){
  if (!("moons" %in% class(moons))){
    stop("`moons` is not of class moons")
  }
  if (!("covariates_options") %in% class(options_covariates)){
    stop("`options_covariates` is not a covariates_options list")
  } 
  
  lead_time <- options_covariates$lead_time - options_covariates$min_lag

  if(!lead_time %in% 1:7){
    stop(paste0("Lead time must be an integer 1 - 7, got: ", lead_time))
  }

  climate_model <- "ENSMEAN"
  lat <- 31.9555
  lon <- -109.0744

  last_moon <- tail(moons, 1)
  last_moon$newmoondate <- as.Date(as.character(last_moon$newmoondate))
  future_moons <- get_future_moons(moons, num_future_moons = lead_time)
  start_time <- as.character(as.Date(last_moon$newmoondate) + 1)
  end_time <- future_moons$newmoondate[lead_time]
  days_for_forecast <- seq.Date(as.Date(start_time), as.Date(end_time), 1)
  daily_forecasts <- data.frame(date = days_for_forecast)
  start_time <- paste0(start_time, "T00%3A00%3A00Z")
  end_time <- paste0(end_time, "T00%3A00%3A00Z")
  
  base_url_1 <- "https://tds-proxy.nkn.uidaho.edu/thredds/ncss/"
  base_url_2 <- "NWCSC_INTEGRATED_SCENARIOS_ALL_CLIMATE/bcsd-nmme/"
  base_url_3 <- "dailyForecasts/bcsd_nmme_metdata_"
  base_url <- paste(base_url_1, base_url_2, base_url_3, sep = "")
  type_urls <- c("tasmin", "tasmean", "tasmax", "pr")
  full_urls <- paste0(base_url, climate_model, "_forecast_", type_urls, 
                      "_daily.nc?var=", type_urls, "&latitude=", lat, 
                      "&longitude=", lon, "&time_start=", start_time, 
                      "&time_end=", end_time, "&accept=csv")
  raw_download <- getURL(full_urls)
  df1 <- read.table(sep = ",", skip = 1, text = raw_download[1])
  df2 <- read.table(sep = ",", skip = 1, text = raw_download[2])
  df3 <- read.table(sep = ",", skip = 1, text = raw_download[3])
  df4 <- read.table(sep = ",", skip = 1, text = raw_download[4])
  colnames(df1) <- c("date", "lat", "lon", "mintemp")
  colnames(df2) <- c("date", "lat", "lon", "meantemp")
  colnames(df3) <- c("date", "lat", "lon", "maxtemp")
  colnames(df4) <- c("date", "lat", "lon", "precipitation")
  df1$mintemp[df1$mintemp == -9999] <- NA
  df2$meantemp[df2$meantemp == -9999] <- NA
  df3$maxtemp[df3$maxtemp == -9999] <- NA
  df4$precipitation[which(df4$precipitation < 0)] <- 0
  df <- df1 %>% 
        right_join(df2, by = c("date", "lat", "lon")) %>% 
        right_join(df3, by = c("date", "lat", "lon")) %>% 
        right_join(df4, by = c("date", "lat", "lon")) %>% 
        mutate(date = as_date(date)) %>% 
        select(-lat, -lon) %>%
        mutate(mintemp = (mintemp - 32) * 5 / 9) %>%
        mutate(maxtemp = (maxtemp - 32) * 5 / 9) %>%
        mutate(meantemp = (meantemp - 32) * 5 / 9) %>%
        mutate(precipitation = precipitation * 25.4)

  daily_fcast <- full_join(daily_forecasts, df, by = "date")

  hist_path <- main_path(options_covariates$tree)
  historic <- weather("daily", fill = TRUE, path = hist_path)
  datechar <- paste(historic$year, historic$month, historic$day, sep = "-")
  historic$date <- as.Date(datechar)

  avail_historic <- which(daily_forecasts$date %in% historic$date)
  n_avail_historic <- length(avail_historic)

  if(n_avail_historic > 0){
    dates_avail <- daily_fcast$date[avail_historic]
    in_hist <- which(historic$date %in% dates_avail)
    in_fcast <- which(daily_fcast$date %in% dates_avail)
    daily_fcast$mintemp[in_fcast] <- historic$mintemp[in_hist]
    daily_fcast$meantemp[in_fcast] <- historic$meantemp[in_hist]
    daily_fcast$maxtemp[in_fcast] <- historic$maxtemp[in_hist]
    daily_fcast$precipitation[in_fcast] <- historic$precipitation[in_hist]
  }

  temp_moons <- rbind(last_moon, future_moons)
  newmoon_number <- temp_moons$newmoonnumber[-1]
  newmoon_start <- temp_moons$newmoondate[-(1 + lead_time)] 
  newmoon_end <- temp_moons$newmoondate[-1]
  newmoon_match_number <- NULL
  newmoon_match_date <- NULL
  for(i in 1:lead_time){
    date_seq <- seq.Date(newmoon_start[i] + 1, newmoon_end[i], 1)
    if (date_seq[length(date_seq)] != newmoon_end[i]){
      date_seq <- c(date_seq, newmoon_end[i])
    }
    temp_dates <- as.character(date_seq)
    temp_numbers <- rep(newmoon_number[i], length(temp_dates))
    newmoon_match_date <- c(newmoon_match_date, temp_dates)
    newmoon_match_number <- c(newmoon_match_number, temp_numbers)   
  }  
  newmoon_match_date <- as.Date(newmoon_match_date)
  which_match <- match(daily_forecasts$date, newmoon_match_date)
  daily_fcast$newmoonnumber <- newmoon_match_number[which_match]

  daily_fcast %>% 
  group_by(newmoonnumber) %>%
  summarize(mintemp = min(mintemp, na.rm = T), 
            maxtemp = max(maxtemp, na.rm = T), 
            meantemp = mean(meantemp, na.rm = T), 
            precipitation = sum(precipitation, na.rm = T)) %>%
  classy(c("climate_forecast", "data.frame", "tbl_df", "tbl"))

}

#' @title Append a covariate forecast to existing covariate forecasts
#' 
#' @description Add the newest weather and NDVI forecasts to the existing 
#'   forecasts data file, for use in future hindcasting.
#' 
#' @param new_forecast_covariates Class-\code{covariates} \code{data.frame} of
#'   forecasted covariate data generated by 
#'   \code{\link{forecast_covariates}}.
#'
#' @param options_covariates Class-\code{covariates_options} options 
#'   \code{list}. See \code{\link{covariates_options}}.
#' 
#' @return \code{new_forecast_covariates} exactly as input.
#'
#' @export
#'
append_cov_fcast_csv <- function(new_forecast_covariates, 
                                 options_covariates = covariates_options()){
  if (!("covariates" %in% class(new_forecast_covariates))){
    stop("`new_forecast_covariates` is not of class covariates")
  }
  if (!("covariates_options") %in% class(options_covariates)){
    stop("`options_covariates` is not a covariates_options list")
  } 
  
  if (!options_covariates$append_fcast_csv){
    return(new_forecast_covariates)
  }
  if (options_covariates$cast_type == "hindcast"){
    return(new_forecast_covariates)
  }

  covar_new <- new_forecast_covariates
  covar_new$source <- options_covariates$source_name
  date_made <- today(time = TRUE)
  tz <- format(date_made, "%Z")
  covar_new$date_made <- paste0(date_made, " ", tz)

  fname <- paste0("data/", options_covariates$hist_fcast_file)
  hist_file <- file_path(options_covariates$tree, fname)

  if (file.exists(hist_file)){
    covar_hist <- read.csv(hist_file, stringsAsFactors = FALSE)
    out <- rbind(covar_hist, covar_new)
  } else{
    out <- covar_new
  }
  write.csv(out, hist_file, row.names = FALSE)
  new_forecast_covariates
}
